<!DOCTYPE html>
<html lang="zh-Hans">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="排序##排序概念


按关键字将数据元素（记录）有序排列
多个关键字可以转化为单个关键字排序


####排序的稳定性
稳定：排序前领先，排序后仍然领先即为稳定
####内排序和外排序    内排序：待排序记录全部放置于内存中；    外排序：记录数太多，整个排序需要在内外存之间多次交换数据。

时">
    

    <!--Author-->
    
        <meta name="author" content="Kaiser">
    

    <!-- Title -->
    
    <title>Sort | Kaiser34</title>

    <!-- Bootstrap Core CSS -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body>

    <!-- Content -->
    <section class="article-container">
<!-- Back Home -->
<a class="nav-back" href="/">
    <i class="fa fa-puzzle-piece"></i>
</a>

<!-- Page Header -->
<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Sort</h1>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Main Content -->
            <div class="post-content col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>##排序概念</p>
<blockquote>
<ul>
<li>按关键字将数据元素（<strong>记录</strong>）有序排列</li>
<li>多个关键字可以转化为<strong>单个关键字</strong>排序</li>
</ul>
</blockquote>
<p>####排序的稳定性</p>
<p><strong>稳定：排序前领先，排序后仍然领先即为稳定</strong></p>
<p>####内排序和外排序<br>    内排序：待排序记录全部放置于内存中；<br>    外排序：记录数太多，整个排序需要在内外存之间多次交换数据。</p>
<ul>
<li>时间性能<ul>
<li>内排：比较和移动</li>
<li>尽可能减少比较次数和记录移动次数</li>
</ul>
</li>
<li>辅助空间</li>
<li>算法复杂性<ul>
<li>内排：<code>插入排序、交换排序、选择排序、并归排序</code> </li>
</ul>
</li>
</ul>
<p>##排序算法</p>
<p>####冒泡排序</p>
<blockquote>
<p>特点：<strong>两两比较相邻记录关键字</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </div><div class="line"><span class="comment">//整數或浮點數皆可使用,若要使用物件(class)時必須設定大於(&gt;)的運算子功能</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</div><div class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</div><div class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</div><div class="line">				swap(arr[j], arr[j + <span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> arr[] = &#123; <span class="number">61</span>, <span class="number">17</span>, <span class="number">29</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">60</span>, <span class="number">72</span>, <span class="number">21</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">62</span> &#125;;</div><div class="line">	<span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</div><div class="line">	bubble_sort(arr, len);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">' '</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</div><div class="line">	len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arrf) / <span class="keyword">sizeof</span>(*arrf);</div><div class="line">	bubble_sort(arrf, len);</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">		<span class="built_in">cout</span> &lt;&lt; arrf[i] &lt;&lt; <span class="string">' '</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//冒泡排序优化1  </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">size_t</span> size)</span>  </span></div><div class="line">&#123;  </div><div class="line">    assert(arr);  </div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)<span class="comment">//一共要排序size-1次  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="comment">//每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换  </span></div><div class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;  </div><div class="line">  </div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size - <span class="number">1</span> - i; j++)<span class="comment">//选出该趟排序的最大值往后移动  </span></div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])  </div><div class="line">            &#123;  </div><div class="line">                <span class="keyword">int</span> tmp = arr[j];  </div><div class="line">                arr[j] = arr[j + <span class="number">1</span>];  </div><div class="line">                arr[j + <span class="number">1</span>] = tmp;  </div><div class="line">                flag = <span class="number">1</span>;<span class="comment">//只要有发生了交换，flag就置为1  </span></div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">//判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return  </span></div><div class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">//冒泡排序优化2  </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort3</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">size_t</span> size)</span>  </span></div><div class="line">&#123;  </div><div class="line">    assert(arr);  </div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">int</span> k = size - <span class="number">1</span>,pos = <span class="number">0</span>;<span class="comment">//pos变量用来标记循环里最后一次交换的位置    </span></div><div class="line">      </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)<span class="comment">//一共要排序size-1次  </span></div><div class="line">    &#123;  </div><div class="line">        <span class="comment">//每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换  </span></div><div class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;  </div><div class="line">  </div><div class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;k; j++)<span class="comment">//选出该趟排序的最大值往后移动  </span></div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])  </div><div class="line">            &#123;  </div><div class="line">                <span class="keyword">int</span> tmp = arr[j];  </div><div class="line">                arr[j] = arr[j + <span class="number">1</span>];  </div><div class="line">                arr[j + <span class="number">1</span>] = tmp;  </div><div class="line">                flag = <span class="number">1</span>;<span class="comment">//只要有发生了交换，flag就置为1  </span></div><div class="line">                pos = j;<span class="comment">//循环里最后一次交换的位置 j赋给pos  </span></div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        k = pos;  </div><div class="line">        <span class="comment">//判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return  </span></div><div class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>)  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>####选择排序</p>
<blockquote>
<p>特点：</p>
<ul>
<li><strong>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</strong></li>
<li>原地排序<br>​                      </li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </div><div class="line"><span class="comment">//整數或浮點數皆可使用,若要使用物件(class)時必須設定大於(&gt;)的運算子功能</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i, j, min;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</div><div class="line">		min = i;</div><div class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)</div><div class="line">			<span class="keyword">if</span> (arr[min] &gt; arr[j])</div><div class="line">				min = j;</div><div class="line">		swap(arr[i], arr[min]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####<a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" target="_blank" rel="external">插入排序</a></p>
<blockquote>
<p>特点：将一个记录插入到已经排好序的有序表中(in-place)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </div><div class="line"><span class="comment">//整數或浮點數皆可使用,若要使用物件(class)時必須設定大於(&gt;)的運算子功能</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i, j;</div><div class="line">	T temp;</div><div class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; i++) &#123;</div><div class="line">		temp = arr[i];</div><div class="line">		<span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j--)</div><div class="line">			arr[j + <span class="number">1</span>] = arr[j];</div><div class="line">		arr[j + <span class="number">1</span>] = temp;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。</strong></p>
<p>####希尔排序</p>
<p>希尔排序，也称<strong>递减增量排序算法</strong>，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </div><div class="line"><span class="comment">//整數或浮點數皆可使用,若要使用物件(class)時必須設定大於(&gt;)的運算子功能</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> gap, i, j;</div><div class="line">	T temp;</div><div class="line">	<span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)</div><div class="line">		<span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</div><div class="line">			temp = arr[i];</div><div class="line">			<span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</div><div class="line">				arr[j + gap] = arr[j];</div><div class="line">			arr[j + gap] = temp;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####堆排序</p>
<blockquote>
<p>堆排序在<strong>top K 问题</strong>中使用比较频繁。堆排序是采用<strong>二叉堆</strong>的数据结构来实现的，虽然实质上还是一维数组。二叉堆是一个近似<strong>完全二叉树</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> HeapSort &#123;</div><div class="line">    <span class="comment">// get the parent node index</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// get the left child node index</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// get the right child node index</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// build max heap</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> heap_size)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heap_size / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            max_heapify(nums, i, heap_size);</div><div class="line">        &#125;</div><div class="line">        print_heap(nums, heap_size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// build min heap</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_min_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> heap_size)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heap_size / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            min_heapify(nums, i, heap_size);</div><div class="line">        &#125;</div><div class="line">        print_heap(nums, heap_size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// adjust the heap to max-heap</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        <span class="comment">// int len = nums.size();</span></div><div class="line">        <span class="keyword">while</span> (k &lt; len) &#123;</div><div class="line">            <span class="keyword">int</span> max_index = k;</div><div class="line">            <span class="comment">// left leaf node search</span></div><div class="line">            <span class="keyword">int</span> l = left(k);</div><div class="line">            <span class="keyword">if</span> (l &lt; len &amp;&amp; nums[l] &gt; nums[max_index]) &#123;</div><div class="line">                max_index = l;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// right leaf node search</span></div><div class="line">            <span class="keyword">int</span> r = right(k);</div><div class="line">            <span class="keyword">if</span> (r &lt; len &amp;&amp; nums[r] &gt; nums[max_index]) &#123;</div><div class="line">                max_index = r;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// node after k are max-heap already</span></div><div class="line">            <span class="keyword">if</span> (k == max_index) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// keep the root node the largest</span></div><div class="line">            <span class="keyword">int</span> temp = nums[k];</div><div class="line">            nums[k] = nums[max_index];</div><div class="line">            nums[max_index] = temp;</div><div class="line">            <span class="comment">// adjust not only just current index</span></div><div class="line">            k = max_index;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// adjust the heap to min-heap</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">min_heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        <span class="comment">// int len = nums.size();</span></div><div class="line">        <span class="keyword">while</span> (k &lt; len) &#123;</div><div class="line">            <span class="keyword">int</span> min_index = k;</div><div class="line">            <span class="comment">// left leaf node search</span></div><div class="line">            <span class="keyword">int</span> l = left(k);</div><div class="line">            <span class="keyword">if</span> (l &lt; len &amp;&amp; nums[l] &lt; nums[min_index]) &#123;</div><div class="line">                min_index = l;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// right leaf node search</span></div><div class="line">            <span class="keyword">int</span> r = right(k);</div><div class="line">            <span class="keyword">if</span> (r &lt; len &amp;&amp; nums[r] &lt; nums[min_index]) &#123;</div><div class="line">                min_index = r;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// node after k are min-heap already</span></div><div class="line">            <span class="keyword">if</span> (k == min_index) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// keep the root node the largest</span></div><div class="line">            <span class="keyword">int</span> temp = nums[k];</div><div class="line">            nums[k] = nums[min_index];</div><div class="line">            nums[min_index] = temp;</div><div class="line">            <span class="comment">// adjust not only just current index</span></div><div class="line">            k = min_index;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">// heap sort</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> len = nums.size();</div><div class="line">        <span class="comment">// init heap structure</span></div><div class="line">        build_max_heapify(nums, len);</div><div class="line">        <span class="comment">// heap sort</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">            <span class="comment">// put the largest number int the last</span></div><div class="line">            <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</div><div class="line">            nums[<span class="number">0</span>] = nums[i];</div><div class="line">            nums[i] = temp;</div><div class="line">            <span class="comment">// reconstruct heap</span></div><div class="line">            build_max_heapify(nums, i);</div><div class="line">        &#125;</div><div class="line">        print_heap(nums, len);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// print heap between [0, heap_size - 1]</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> heap_size)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heap_size; ++i) &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">", "</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">19</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">11</span>&#125;;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(A[<span class="number">0</span>]); ++i) &#123;</div><div class="line">        nums.push_back(A[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    HeapSort sort;</div><div class="line">    sort.print_heap(nums, nums.size());</div><div class="line">    sort.heap_sort(nums);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####并归排序</p>
<blockquote>
<p>归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作，归并排序算法依赖归并操作。</p>
</blockquote>
<p><img src="http://algs4.cs.princeton.edu/22mergesort/images/mergesortTD.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">迭代版:</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">	T* a = arr;</div><div class="line">	T* b = <span class="keyword">new</span> T[len];</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</div><div class="line">			<span class="keyword">int</span> low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);</div><div class="line">			<span class="keyword">int</span> k = low;</div><div class="line">			<span class="keyword">int</span> start1 = low, end1 = mid;</div><div class="line">			<span class="keyword">int</span> start2 = mid, end2 = high;</div><div class="line">			<span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</div><div class="line">				b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</div><div class="line">			<span class="keyword">while</span> (start1 &lt; end1)</div><div class="line">				b[k++] = a[start1++];</div><div class="line">			<span class="keyword">while</span> (start2 &lt; end2)</div><div class="line">				b[k++] = a[start2++];</div><div class="line">		&#125;</div><div class="line">		T* temp = a;</div><div class="line">		a = b;</div><div class="line">		b = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (a != arr) &#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</div><div class="line">			b[i] = a[i];</div><div class="line">		b = a;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">delete</span>[] b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">递归版：</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge</span> </span>&#123;</div><div class="line">    <span class="comment">// This class should not be instantiated.</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Merge</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="comment">// stably merge a[lo .. mid] with a[mid+1 ..hi] using aux[lo .. hi]</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">        <span class="comment">// precondition: a[lo .. mid] and a[mid+1 .. hi] are sorted subarrays</span></div><div class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, mid)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, mid+<span class="number">1</span>, hi)</span></span>;</div><div class="line"></div><div class="line">        <span class="comment">// copy to aux[]</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">            aux[k] = a[k]; </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// merge back to a[]</span></div><div class="line">        <span class="keyword">int</span> i = lo, j = mid+<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</div><div class="line">            <span class="keyword">if</span>      (i &gt; mid)              a[k] = aux[j++];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi)               a[k] = aux[i++];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (less(aux[j], aux[i])) a[k] = aux[j++];</div><div class="line">            <span class="keyword">else</span>                           a[k] = aux[i++];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// postcondition: a[lo .. hi] is sorted</span></div><div class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, hi)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// mergesort a[lo..hi] using auxiliary array aux[lo..hi]</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, Comparable[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</div><div class="line">        sort(a, aux, lo, mid);</div><div class="line">        sort(a, aux, mid + <span class="number">1</span>, hi);</div><div class="line">        merge(a, aux, lo, mid, hi);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>####快速排序</p>
<p><img src="http://algs4.cs.princeton.edu/23quicksort/images/quicksort.png" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// quicksort the subarray from a[lo] to a[hi]</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123; </div><div class="line">     <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</div><div class="line">     <span class="keyword">int</span> j = partition(a, lo, hi);</div><div class="line">     sort(a, lo, j-<span class="number">1</span>);</div><div class="line">     sort(a, j+<span class="number">1</span>, hi);</div><div class="line">     <span class="function"><span class="keyword">assert</span> <span class="title">isSorted</span><span class="params">(a, lo, hi)</span></span>;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="comment">// partition the subarray a[lo..hi] so that a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi]</span></div><div class="line"> <span class="comment">// and return the index j.</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> i = lo;</div><div class="line">     <span class="keyword">int</span> j = hi + <span class="number">1</span>;</div><div class="line">     Comparable v = a[lo];</div><div class="line">     <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; </div><div class="line"></div><div class="line">         <span class="comment">// find item on lo to swap</span></div><div class="line">         <span class="keyword">while</span> (less(a[++i], v))</div><div class="line">             <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">         <span class="comment">// find item on hi to swap</span></div><div class="line">         <span class="keyword">while</span> (less(v, a[--j]))</div><div class="line">             <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;      <span class="comment">// redundant since a[lo] acts as sentinel</span></div><div class="line"></div><div class="line">         <span class="comment">// check if pointers cross</span></div><div class="line">         <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</div><div class="line"></div><div class="line">         exch(a, i, j);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// put partitioning item v at a[j]</span></div><div class="line">     exch(a, lo, j);</div><div class="line"></div><div class="line">     <span class="comment">// now, a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]</span></div><div class="line">     <span class="keyword">return</span> j;</div><div class="line"> &#125;</div><div class="line"><span class="comment">// exchange a[i] and a[j]</span></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Object[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">     Object swap = a[i];</div><div class="line">     a[i] = a[j];</div><div class="line">     a[j] = swap;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>####桶排序</p>
<blockquote>
<p>桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间。但桶排序并不是比较排序，他不受到O(nlogn)下限的影响。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">平均时间</th>
<th style="text-align:center">最差时间</th>
<th style="text-align:center">空间最差</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$O(n+k)$</td>
<td style="text-align:center">$O(n^2 )$</td>
<td style="text-align:center">$O(n*k)$</td>
</tr>
</tbody>
</table>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">#include&lt;iterator&gt;</div><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line">const int BUCKET_NUM = 10;</div><div class="line"></div><div class="line">struct ListNode&#123;</div><div class="line">	explicit ListNode(int i=0):mData(i),mNext(NULL)&#123;&#125;</div><div class="line">	ListNode* mNext;</div><div class="line">	int mData;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">ListNode* insert(ListNode* head,int val)&#123;</div><div class="line">	ListNode dummyNode;</div><div class="line">	ListNode *newNode = new ListNode(val);</div><div class="line">	ListNode *pre,*curr;</div><div class="line">	dummyNode.mNext = head;</div><div class="line">	pre = &amp;dummyNode;</div><div class="line">	curr = head;</div><div class="line">	while(NULL!=curr &amp;&amp; curr-&gt;mData&lt;=val)&#123;</div><div class="line">		pre = curr;</div><div class="line">		curr = curr-&gt;mNext;</div><div class="line">	&#125;</div><div class="line">	newNode-&gt;mNext = curr;</div><div class="line">	pre-&gt;mNext = newNode;</div><div class="line">	return dummyNode.mNext;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">ListNode* Merge(ListNode *head1,ListNode *head2)&#123;</div><div class="line">	ListNode dummyNode;</div><div class="line">	ListNode *dummy = &amp;dummyNode;</div><div class="line">	while(NULL!=head1 &amp;&amp; NULL!=head2)&#123;</div><div class="line">		if(head1-&gt;mData &lt;= head2-&gt;mData)&#123;</div><div class="line">			dummy-&gt;mNext = head1;</div><div class="line">			head1 = head1-&gt;mNext;</div><div class="line">		&#125;else&#123;</div><div class="line">			dummy-&gt;mNext = head2;</div><div class="line">			head2 = head2-&gt;mNext;</div><div class="line">		&#125;</div><div class="line">		dummy = dummy-&gt;mNext;</div><div class="line">	&#125;</div><div class="line">	if(NULL!=head1) dummy-&gt;mNext = head1;</div><div class="line">	if(NULL!=head2) dummy-&gt;mNext = head2;</div><div class="line">	</div><div class="line">	return dummyNode.mNext;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void BucketSort(int n,int arr[])&#123;</div><div class="line">	vector&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(0));</div><div class="line">	for(int i=0;i&lt;n;++i)&#123;</div><div class="line">		int index = arr[i]/BUCKET_NUM;</div><div class="line">		ListNode *head = buckets.at(index);</div><div class="line">		buckets.at(index) = insert(head,arr[i]);</div><div class="line">	&#125;</div><div class="line">	ListNode *head = buckets.at(0);</div><div class="line">	for(int i=1;i&lt;BUCKET_NUM;++i)&#123;</div><div class="line">		head = Merge(head,buckets.at(i));</div><div class="line">	&#125;</div><div class="line">	for(int i=0;i&lt;n;++i)&#123;</div><div class="line">		arr[i] = head-&gt;mData;</div><div class="line">		head = head-&gt;mNext;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####基数排序<br>|   最差时间    |   空间最差   |<br>| :——-: | :——: |<br>| $O(n<em>k )$ | $O(n</em>k)$ |</p>
<p>####计数排序<br>|   最优时间   |   平均时间   |   最差时间   |   空间最差   |<br>| :——: | :——: | :——: | :——: |<br>| $O(n+k)$ | $Q(n+k)$ | $O(n+k)$ | $O(n+k)$ |</p>
<hr>
<p><a href="http://algs4.cs.princeton.edu/20sorting/" target="_blank" rel="external">算法导论</a></p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="external">算法可视化</a></p>

 
                <!-- Meta -->
                <div class="post-meta">
                    <hr>
                    <br>
                    <div class="post-tags">
                        
                    </div>
                    <div class="post-date">
                        2016 年 08 月 04 日
                    </div>
                </div>
            </div>

            <!-- Comments -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- Disqus Comments -->


            </div>
        </div>
    </div>
</article>
</section>

    <!-- Scripts -->
    <!-- jQuery -->
<script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<!-- Bootstrap -->
<script src="//cdn.bootcss.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<script type="text/javascript">
	console.log('Hexo-theme-hollow designed by zchen9 🙋 © 2015-' + (new Date()).getFullYear());
</script>


</body>

</html>